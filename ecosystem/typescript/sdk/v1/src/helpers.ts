import { MemoizeExpiring } from "typescript-memoize";
import { sleep } from "./util";
import { AptosAccount } from "./aptos_account";
import { HexString, MaybeHexString } from "./hex_string";
import * as Gen from "./generated/index";
import { TxnBuilderTypes, TransactionBuilderEd25519 } from "./transaction_builder";

export class Helpers {
  constructor(public readonly client: Gen.AptosGeneratedClient) {}

  /** Generates a signed transaction that can be submitted to the chain for execution. */
  static generateBCSTransaction(accountFrom: AptosAccount, rawTxn: TxnBuilderTypes.RawTransaction): Uint8Array {
    const txnBuilder = new TransactionBuilderEd25519((signingMessage: TxnBuilderTypes.SigningMessage) => {
      // @ts-ignore
      const sigHexStr = accountFrom.signBuffer(signingMessage);
      return new TxnBuilderTypes.Ed25519Signature(sigHexStr.toUint8Array());
    }, accountFrom.pubKey().toUint8Array());

    return txnBuilder.sign(rawTxn);
  }

  /** Generates a BCS transaction that can be submitted to the chain for simulation. */
  static generateBCSSimulation(accountFrom: AptosAccount, rawTxn: TxnBuilderTypes.RawTransaction): Uint8Array {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const txnBuilder = new TransactionBuilderEd25519((_signingMessage: TxnBuilderTypes.SigningMessage) => {
      // @ts-ignore
      const invalidSigBytes = new Uint8Array(64);
      return new TxnBuilderTypes.Ed25519Signature(invalidSigBytes);
    }, accountFrom.pubKey().toUint8Array());

    return txnBuilder.sign(rawTxn);
  }

  /** Generates a transaction request that can be submitted to produce a raw transaction that
   * can be signed, which upon being signed can be submitted to the blockchain
   * @param sender Hex-encoded 32 byte Aptos account address of transaction sender
   * @param payload Transaction payload. It depends on transaction type you want to send
   * @param options Options allow to overwrite default transaction options.
   * Defaults are:
   * ```bash
   *   {
   *     sender: senderAddress.hex(),
   *     sequence_number: account.sequence_number,
   *     max_gas_amount: "1000",
   *     gas_unit_price: "1",
   *     gas_currency_code: "XUS",
   *     // Unix timestamp, in seconds + 10 seconds
   *     expiration_timestamp_secs: (Math.floor(Date.now() / 1000) + 10).toString(),
   *   }
   * ```
   * @returns A transaction object
   */
  async generateTransaction(
    sender: MaybeHexString,
    payload: Gen.TransactionPayload,
    options?: Partial<Gen.SubmitTransactionRequest>,
  ): Promise<Gen.SubmitTransactionRequest> {
    const senderAddress = HexString.ensure(sender);
    const account = await this.client.accounts.getAccount(senderAddress.toString());
    const fakeSignature: Gen.TransactionSignature = {
      type: "ed_25519_signature",
      public_key: sender.toString(),
      signature: HexString.fromUint8Array(new Uint8Array(32)).hex(),
    };
    return {
      // Use a fake signature.
      signature: fakeSignature,
      sender: senderAddress.hex(),
      sequence_number: account.sequence_number,
      max_gas_amount: "1000",
      gas_unit_price: "1",
      // Unix timestamp, in seconds + 10 seconds
      expiration_timestamp_secs: (Math.floor(Date.now() / 1000) + 10).toString(),
      payload,
      ...(options || {}),
    };
  }

  /** Converts a transaction request produced by `generateTransaction` into a properly
   * signed transaction, which can then be submitted to the blockchain
   * @param accountFrom AptosAccount of transaction sender
   * @param txnRequest A raw transaction generated by `generateTransaction` method
   * @returns A transaction, signed with sender account
   */
  async signTransaction(
    accountFrom: AptosAccount,
    txnRequest: Gen.SubmitTransactionRequest,
  ): Promise<Gen.SubmitTransactionRequest> {
    const message = await this.client.transactions.encodeSubmission(txnRequest);
    const signatureHex = accountFrom.signHexString(message.substring(2));

    const transactionSignature: Gen.TransactionSignature = {
      type: "ed_25519_signature",
      public_key: accountFrom.pubKey().hex(),
      signature: signatureHex.hex(),
    };

    return { ...txnRequest, signature: transactionSignature };
  }

  /** Submits a transaction with fake signature to the transaction simulation endpoint that takes JSON payload. */
  async simulateTransaction(
    accountFrom: AptosAccount,
    txnRequest: Gen.SubmitTransactionRequest,
  ): Promise<Gen.UserTransaction[]> {
    const transactionSignature: Gen.TransactionSignature = {
      type: "ed_25519_signature",
      public_key: accountFrom.pubKey().hex(),
      // use invalid signature for simulation
      signature: HexString.fromUint8Array(new Uint8Array(64)).hex(),
    };

    const request = { ...txnRequest, signature: transactionSignature };
    return await this.client.transactions.simulateTransaction(request);
  }

  /**
   * Submits a signed transaction to the the endpoint that takes BCS payload
   * @param signedTxn A BCS transaction representation
   * @returns Transaction that is accepted and submitted to mempool
   */
  async submitSignedBCSTransaction(signedTxn: Uint8Array): Promise<Gen.PendingTransaction> {
    // Need to construct a customized post request for transactions in BCS payload
    return await this.client.request.request<Gen.PendingTransaction>({
      url: "/transactions",
      method: "POST",
      body: signedTxn,
      mediaType: "application/x.aptos.signed_transaction+bcs",
    });
  }

  /**
   * Submits a signed transaction to the the endpoint that takes BCS payload
   * @param signedTxn output of generateBCSSimulation()
   * @returns Simulation result in the form of UserTransaction
   */
  async submitBCSSimulation(bcsBody: Uint8Array): Promise<Gen.UserTransaction[]> {
    // Need to construct a customized post request for transactions in BCS payload
    return await this.client.request.request<Gen.UserTransaction[]>({
      url: "/transactions/simulate",
      method: "POST",
      body: bcsBody,
      mediaType: "application/x.aptos.signed_transaction+bcs",
    });
  }

  /**
   * Defines if specified transaction is currently in pending state
   * @param txnHash A hash of transaction
   *
   * To create a transaction hash:
   *
   * 1. Create hash message bytes: "Aptos::Transaction" bytes + BCS bytes of Transaction.
   * 2. Apply hash algorithm SHA3-256 to the hash message bytes.
   * 3. Hex-encode the hash bytes with 0x prefix.
   *
   * @returns `true` if transaction is in pending state and `false` otherwise
   */
  async transactionPending(txnHash: string): Promise<boolean> {
    try {
      const response = await this.client.transactions.getTransactionByHash(txnHash);
      return response.type === "pending_transaction";
    } catch (e) {
      if (e instanceof Gen.ApiError) {
        return e.status === 404;
      }
      throw e;
    }
  }

  /**
   * Waits up to 10 seconds for a transaction to move past pending state
   * @param txnHash A hash of transaction
   * @returns A Promise, that will resolve if transaction is accepted to the blockchain,
   * and reject if more then 10 seconds passed
   * @example
   * ```
   * const signedTxn = await this.aptosClient.signTransaction(account, txnRequest);
   * const res = await this.aptosClient.submitTransaction(signedTxn);
   * await this.aptosClient.waitForTransaction(res.hash);
   * // do smth after transaction is accepted into blockchain
   * ```
   */
  async waitForTransaction(txnHash: string) {
    let count = 0;
    // eslint-disable-next-line no-await-in-loop
    while (await this.transactionPending(txnHash)) {
      // eslint-disable-next-line no-await-in-loop
      await sleep(1000);
      count += 1;
      if (count >= 10) {
        throw new Error(`Waiting for transaction ${txnHash} timed out!`);
      }
    }
  }

  /**
   * @param params Request params
   * @returns Current chain id
   */
  @MemoizeExpiring(5 * 60 * 1000) // cache result for 5 minutes
  async getChainId(): Promise<number> {
    const result = await this.client.general.getLedgerInfo();
    return result.chain_id;
  }
}
