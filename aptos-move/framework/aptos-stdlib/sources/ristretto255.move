/// Contains functions for Ristretto255 curve arithmetic.
///
/// The order of this elliptic curve group is $\ell = 2^252 + 27742317777372353535851937790883648493$, same as the order
/// of the prime-order subgroup of Curve25519.
module cryptography::ristretto255 {
    use std::option::Option;

    // TODO: compressedpoint struct (to store on chain)
    // TODO: point struct (to do fast arithmetic with)
    //  - hash_from_bytes<D: Digest>
    //  - from_uniform_bytes
    //  - equals
    //  - add(_assign), sub(_assign), neg(_assign), double(_assign), mul(_assign),
    //  - hash, msm
    // TODO: scalar struct
    //  - hash_from_bytes
    //  - zero, one
    //  - from_u32/u64/u128
    //  - arithmetic
    //  - invert

    struct Scalar has key, store, drop {
        data: vector<u8>
    }

    /// Only used internally when constructing a Scalar from a sequence of possibly-non-canonical bytes.
    native fun is_canonical(s: vector<u8>): bool;

    /// Returns a Scalar from a sequence of 32 canonically-encoded bytes: i.e., the unsigned big integer encoded in
    /// these bytes is less than the Ristretto group order $\ell$.
    public fun new_scalar_from_canonical_bytes(bytes: vector<u8>): Option<Scalar> {
        if (is_canonical(bytes)) {
            std::option::some(Scalar {
                data: bytes
            })
        } else {
            std::option::none<Scalar>()
        }
    }

    //
    // Test cases for test_<name> were generated by running `cargo test -- test_sample_<name> --nocapture --include-ignored` in `crates/aptos-crypto`
    //

    #[test]
    /// Tests verification of random BLS proofs-of-possession (PoPs)
    fun test_ristretto255() {
        assert!(std::option::is_none(&new_scalar_from_canonical_bytes(x"00")), 1);
        assert!(std::option::is_some(&new_scalar_from_canonical_bytes(x"0000000000000000000000000000000000000000000000000000000000000000")), 1);

        // Non-canonical high bit is set
        assert!(std::option::is_none(&new_scalar_from_canonical_bytes(x"0000000000000000000000000000000000000000000000000000000000000080")), 1);

        // Non-canonical unreduced
        assert!(std::option::is_none(&new_scalar_from_canonical_bytes(x"1010101010101010101010101010101010101010101010101010101010101010")), 1);

        let non_canonical = vector<u8>[
            0xef, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58,
            0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,
        ];

        assert!(std::option::is_none(&new_scalar_from_canonical_bytes(non_canonical)), 1);
    }
}
